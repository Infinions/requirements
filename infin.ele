-- signatures
sig Company {
	var users: set User,
	var invoices: set Invoice,
	var categories: set Category,
	var tags: set Tag
} 
var sig Registered in Company {}

sig User {}
sig Tag {}
sig Budget {} 

sig Category {
	budget: lone Budget
} 


sig Invoice {
--	company: one Company,
--	category: lone Category,
--	tags: set Tag
}

-- preds
pred emptyCompany[c : Company] {
	some c

	no c.tags 
	no c.categories	 
	no c.users 
	no c.invoices
}

pred emptyInvoice[i : Invoice] {
	some i
}

pred userRegistered[u : User] {
	some c : Registered | u in c.users
}

pred companyRegistered[c : Company] {
	c in Registered
}

pred invoiceProcessed[i : Invoice] {
	some c : Registered | i in c.invoices
}

pred categoryRegistered[cat : Category] {
	some c : Registered | cat in c.categories
}

pred companysCategory[cat : Category, c : Company] {
 	cat in c.categories
}

pred tagRegistered[t : Tag] {
	some c : Registered | t in c.tags
}

pred companyTag[t : Tag, c : Company] {
 	t in c.tags
}

-- actions
pred stutter {
	Registered' = Registered
	all c : Registered | c.users' = c.users and 
                             c.invoices' = c.invoices and
	                       c.categories' = c.categories and
				     c.tags' = c.tags	
}	
	
pred registerUser[u : User, c : Company] {
	emptyCompany[c]
	not companyRegistered[c]
	not userRegistered[u]
	
	c.users' = c.users + u
	Registered' = Registered + c
	
	Registered.invoices' = Registered.invoices
	Registered.categories' = Registered.categories
	Registered.tags' = Registered.tags
	all c0 : Registered | c != c0 implies c.users' = c.users
}

pred addUserToCompany[u : User, c : Company] {
	not userRegistered[u]
	companyRegistered[c]

	c.users' = c.users + u
	
	Registered' = Registered
	Registered.invoices' = Registered.invoices
	Registered.categories' = Registered.categories
	all c0 : Registered | (c != c0 implies c0.users' = c0.users)
}

pred addInvoiceToCompany[i : Invoice, c : Company] {
	companyRegistered[c]
	not invoiceProcessed[i]
	emptyInvoice[i]

	c.invoices' = c.invoices + i
	
	Registered.users' = Registered.users
	Registered.categories' = Registered.categories
	Registered.tags' = Registered.tags
	Registered' = Registered
	all c0 : Registered | (c != c0 implies c0.invoices' = c0.invoices)
}

pred addCategoryToCompany[cat : Category, c : Company] {
	companyRegistered[c]
	not categoryRegistered[cat]

	c.categories' = c.categories + cat
	
	Registered.users' = Registered.users
	Registered.invoices' = Registered.invoices
	Registered.tags' = Registered.tags
	Registered' = Registered
	all c0 : Registered | (c != c0 implies c0.categories' = c0.categories)
}

pred addTagToCompany[t : Tag, c : Company] {
	companyRegistered[c]
	not tagRegistered[t]

	c.tags' = c.tags + t
	
	Registered.users' = Registered.users
	Registered.invoices' = Registered.invoices
	Registered.categories' = Registered.categories
	Registered' = Registered
	all c0 : Registered | (c != c0 implies c0.tags' = c0.tags)
}


fact traces {
	no Registered

	no Budget


	always (
		some u : User | some c : Company | some i : Invoice | some cat : Category | some t : Tag |
			registerUser[u, c] or addUserToCompany[u, c] or 
			addInvoiceToCompany[i, c] or addCategoryToCompany[cat, c] or addTagToCompany[t, c] or
			stutter
	)
}

run { some c : Company | emptyCompany[c] } for 3


check UsersBelongToOnlyOneCompany {
	always (
 		all disj c1, c2 : Registered | no c1.users & c2.users
	)
}

check CompanyHasAtLeastOneUser {
	always (
		all c : Registered | some c.users
	)
}

check InvoicesBelongToOnlyOneCompany {
	always (
 		all disj c1, c2 : Registered | no c1.invoices & c2.invoices
	)
}

check CategoriesBelongToOnlyOneCompany {
	always (
 		all disj c1, c2 : Registered | no c1.categories & c2.categories
	)
}

check TagsBelongToOnlyOneCompany {
	always (
 		all disj c1, c2 : Registered | no c1.tags & c2.tags
	)
 }
