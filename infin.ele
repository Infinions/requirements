-- signatures
sig Company {
	var users: set User,
	var invoices: set Invoice,
	var categories: set Category,
	var tags: set Tag
} 
var sig Registered in Company {}

sig User {}
sig Tag {}
sig Budget {} 

sig Category {
	var budget: lone Budget
} 


sig Invoice {
	var company: one Company,
--	var category: lone Category,
--	var tags: set Tag
}

-- preds
pred emptyCompany[c : Company] {
	one c

	no c.tags 
	no c.categories
	no c.categories.budget -- redundant 
	no c.users 
	no c.invoices
}

pred emptyInvoice[i : Invoice] {
	one i

	no i.company
}

pred emptyCategory[cat : Category] {
	one cat
	
	no cat.budget
}

pred userRegistered[u : User] {
	some c : Registered | u in c.users
}

pred companyRegistered[c : Company] {
	c in Registered
}

pred invoiceProcessed[i : Invoice] {
	some c : Registered | i in c.invoices
}

pred categoryRegistered[cat : Category] {
	some c : Registered | cat in c.categories
}

pred companysCategory[cat : Category, c : Company] {
 	cat in c.categories
}

pred tagRegistered[t : Tag] {
	some c : Registered | t in c.tags
}

pred companyTag[t : Tag, c : Company] {
 	t in c.tags
}

-- actions
pred sameUsers {
	all c : Company | c.users' = c.users
}

pred sameInvoices {
	all c : Company | c.invoices' = c.invoices
	all c : Company | all i : c.invoices | i.company' = i.company 
}

pred sameCategories {
	all c : Company | c.categories' = c.categories
}

pred sameTags {
	all c : Company | c.tags' = c.tags
}

pred sameBudgets {
	all cat : Category | cat.budget' = cat.budget
}

pred sameRegistered {
	Registered' = Registered
}

pred stutter {
	sameUsers
	sameInvoices
	sameCategories
	sameTags
	sameRegistered
	sameBudgets
}	

pred registerUser[u : User, c : Company] {
	emptyCompany[c]
	not companyRegistered[c]
	not userRegistered[u]
	
	c.users' = c.users + u
	Registered' = Registered + c
	
	sameInvoices
	sameCategories
	sameTags
	sameBudgets
	all c0 : Company | c != c0 implies c.users' = c.users
}

pred addUserToCompany[u : User, c : Company] {
	not userRegistered[u]
	companyRegistered[c]

	c.users' = c.users + u
	
	sameInvoices
	sameCategories
	sameTags
	sameBudgets
	sameRegistered
	all c0 : Company | c != c0 implies c0.users' = c0.users
}

pred addInvoiceToCompany[i : Invoice, c : Company] {
	companyRegistered[c]
	not invoiceProcessed[i]
	emptyInvoice[i]

	c.invoices' = c.invoices + i
	i.company = c
	
	sameUsers
	sameCategories
	sameTags
	sameBudgets
	sameRegistered
	all c0 : Company | c != c0 implies c0.invoices' = c0.invoices
	all i0 : Invoice | i != i0 implies i0.company' = i0.company
}

pred addCategoryToCompany[cat : Category, c : Company] {
	companyRegistered[c]
	not categoryRegistered[cat]
	emptyCategory[cat]

	c.categories' = c.categories + cat
	
	sameInvoices
	sameUsers
	sameTags
	sameBudgets
	sameRegistered
	all c0 : Company | c != c0 implies c0.categories' = c0.categories
}

pred addTagToCompany[t : Tag, c : Company] {
	companyRegistered[c]
	not tagRegistered[t]

	c.tags' = c.tags + t
	
	sameInvoices
	sameUsers
	sameCategories
	sameBudgets
	sameRegistered
	all c0 : Company | c != c0 implies c0.tags' = c0.tags
}


fact traces {
	no Registered
	always (
		some u : User | some c : Company | some i : Invoice | some t : Tag | some cat : Category |
			 registerUser[u, c] or addUserToCompany[u, c] or 
		       addInvoiceToCompany[i, c] or addTagToCompany[t, c] or addCategoryToCompany[cat, c] or
			stutter
	)
}

run { some c : Company | emptyCompany[c] } for 3


check UsersBelongToOnlyOneCompany {
	always (
 		all disj c1, c2 : Registered | no c1.users & c2.users
	)
}

check CompanyHasAtLeastOneUser {
	always (
		all c : Registered | some c.users
	)
}

check InvoicesBelongToOnlyOneCompany {
	always (
 		all disj c1, c2 : Registered | no c1.invoices & c2.invoices
	)
}

check CategoriesBelongToOnlyOneCompany {
	always (
 		all disj c1, c2 : Registered | no c1.categories & c2.categories
	)
}

check TagsBelongToOnlyOneCompany {
	always (
 		all disj c1, c2 : Registered | no c1.tags & c2.tags
	)
 }

check BudgetsBelongToOnlyOneCompany {
	always (
		all disj c1, c2 : Registered | all cat1 : c1.categories | all cat2 : c2.categories |
			no cat1.budget & cat2.budget
	)
}

check BudgetsBelongToOnlyOneCategory {
	always (
		all c : Registered | all disj cat1, cat2 : c.categories | no cat1.budget & cat2.budget
	)
}

check InvoicesCompanyIsConsistent {
	always (
		all c : Registered | all i : c.invoices | one i.company and i.company = c
	)
}
